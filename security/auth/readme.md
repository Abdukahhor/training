Broken Authentication and Session Management


    User authentication credentials are not protected when stored.
    Predictable login credentials.
    Session IDs are exposed in the URL (e.g., URL rewriting).
    Session IDs are vulnerable to session fixation attacks.
    Session value does not timeout or does not get invalidated after logout.
    Session IDs are not rotated after successful login.
    Passwords, session IDs, and other credentials are sent over unencrypted connections.
    
    -Password length: Minimum password length should be at least eight (8) characters long. 
    Combining this length with complexity makes a password difficult to guess using a brute force attack.
    -Password complexity: Passwords should be a combination of alphanumeric characters. 
    Alphanumeric characters consist of letters, numbers, punctuation marks, mathematical 
    and other conventional symbols.
    -Username/Password Enumeration: Authentication failure responses should not indicate 
    which part of the authentication data was incorrect. For example, instead of 
    "Invalid username" or "Invalid password", just use "Invalid username and/or 
    password" for both. Error responses must be truly identical in both display and source code.
    -Protection against brute force login: Enforce account disabling after an established 
    number of invalid login attempts (e.g., five attempts is common). The account must be 
    disabled for a period of time sufficient to discourage brute force guessing of credentials, 
    but not so long as to allow for a denial-of-service attack to be performed.
    -Two-factor authentication Two-factor authentication is exactly what the name 
    impliesâ€”the requirement of two steps in the authentication process. The first 
    step is typically a password, while the second requirement could be a number of options. 
    It may be an SMS message, a code generated by an authentication app, or even a fingerprint. 
    Obviously, two-factor authentication increases security and makes it more difficult 
    for an attacker to gain access. The right combination of authentication 
    requirements depends on such factors as ease of use and, of course, security. 
    Applications requiring higher levels of security should opt for a combination 
    that is more difficult to breach. 



https://www.owasp.org/index.php/Broken_Authentication_and_Session_Management


JWT Security Best Practices
As you have seen in this article, there's a lot more to JWTs than merely using a symmetric signature. 
Most JWT deployments require the use of asymmetric signatures to ensure security.

Additionally, verifying the signature of an incoming JWT is only the first step. Next, the consumer has to check the reserved "exp" and "nbf" claims to ensure that the JWT is valid. The "iss" and "aud" claims need to be verified to ensure the JWT is used in the proper context.

Finally, using JWTs requires you to set up proper cryptographic key management. JWTs offer a variety of options to manage keys. One way is to identify a particular key using an identifier. More advanced options enable the embedding of a key in the token, or the retrieval of a key from a dedicated key URL. Regardless of the mechanism, the consumer always needs to verify the validity of the key before trusting it.

We have covered much ground in this article. This JWT Security Cheat Sheet provides an overview of all these best practices. It allows you to keep track of these things while you're building your application. And to learn more about securing APIs using open standards protocols, read the white paper on How to Extend Identity Security to your APIs.

https://www.pingidentity.com/en/company/blog/posts/2019/jwt-security-nobody-talks-about.html

https://blog.websecurify.com/2017/02/hacking-json-web-tokens.html
